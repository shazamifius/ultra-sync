use super::{
    behaviour::{AppBehaviour, AppBehaviourEvent},
    protocol::{BlockRequest, BlockResponse, GossipMessage},
};
use futures::prelude::*;
use libp2p::{
    gossipsub, identity, mdns, noise, request_response, swarm, tcp, yamux, PeerId, SwarmBuilder,
};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use tokio::sync::mpsc;
use std::iter;

/// The topic for all gossip messages in our network.
const GOSSIP_TOPIC: &str = "p2p-sync-topic";

/// Represents commands sent from the application logic to the network service.
#[derive(Debug)]
pub enum NetworkCommand {
    Publish(GossipMessage),
    RequestBlock {
        peer_id: PeerId,
        request: BlockRequest,
    },
    SendResponse {
        channel: request_response::ResponseChannel<BlockResponse>,
        response: BlockResponse,
    },
}

/// Represents events emitted by the network service to the application logic.
#[derive(Debug)]
pub enum NetworkEvent {
    GossipMessage(GossipMessage),
    InboundRequest {
        peer_id: PeerId,
        request: BlockRequest,
        channel: request_response::ResponseChannel<BlockResponse>,
    },
    BlockResponse {
        peer_id: PeerId,
        response: BlockResponse,
    },
}

/// The main service that manages the libp2p Swarm.
pub struct NetworkService {
    pub swarm: swarm::Swarm<AppBehaviour>,
    pub command_receiver: mpsc::Receiver<NetworkCommand>,
    pub event_sender: mpsc::Sender<NetworkEvent>,
    topic: gossipsub::IdentTopic,
}

impl NetworkService {
    /// Creates a new NetworkService instance.
    pub async fn new(
        command_receiver: mpsc::Receiver<NetworkCommand>,
        event_sender: mpsc::Sender<NetworkEvent>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        // Create a new identity for this peer.
        let local_keys = identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_keys.public());
        log::info!("Local Peer ID: {}", local_peer_id);

        // Configure Gossipsub
        let message_id_fn = |message: &gossipsub::Message| {
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            gossipsub::MessageId::from(s.finish().to_string())
        };
        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .message_id_fn(message_id_fn)
            .build()?;
        let gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(local_keys.clone()),
            gossipsub_config,
        )?;

        // Create the custom network behaviour.
        let behaviour = AppBehaviour {
            gossipsub,
            mdns: mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?,
            request_response: request_response::Behaviour::new(
                iter::once(("/p2p-sync/req/1", request_response::ProtocolSupport::Full)),
                Default::default(),
            ),
        };

        // Build the Swarm.
        let mut swarm = SwarmBuilder::with_existing_identity(local_keys)
            .with_tokio()
            .with_tcp(
                tcp::Config::default(),
                noise::Config::new,
                yamux::Config::default,
            )?
            .with_behaviour(|_| behaviour)?
            .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
            .build();

        // Subscribe to the main gossip topic.
        let topic = gossipsub::IdentTopic::new(GOSSIP_TOPIC);
        swarm.behaviour_mut().gossipsub.subscribe(&topic)?;

        // Listen on all interfaces and a random OS-assigned port.
        swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

        Ok(Self {
            swarm,
            command_receiver,
            event_sender,
            topic,
        })
    }

    /// The main run loop for the network service.
    pub async fn run(mut self) {
        loop {
            tokio::select! {
                // Handle events from the libp2p Swarm.
                event = self.swarm.select_next_some() => self.handle_swarm_event(event).await,

                // Handle commands from the application logic.
                Some(command) = self.command_receiver.recv() => self.handle_command(command).await,
            }
        }
    }

    /// Handles events generated by the Swarm.
    async fn handle_swarm_event(
        &mut self,
        event: swarm::SwarmEvent<AppBehaviourEvent>,
    ) {
        match event {
            swarm::SwarmEvent::Behaviour(AppBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {
                for (peer_id, _) in list {
                    log::info!("mDNS discovered a new peer: {}", peer_id);
                    self.swarm
                        .behaviour_mut()
                        .gossipsub
                        .add_explicit_peer(&peer_id);
                }
            }
            swarm::SwarmEvent::Behaviour(AppBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
                for (peer_id, _) in list {
                    log::info!("mDNS peer expired: {}", peer_id);
                    self.swarm
                        .behaviour_mut()
                        .gossipsub
                        .remove_explicit_peer(&peer_id);
                }
            }
            swarm::SwarmEvent::Behaviour(AppBehaviourEvent::Gossipsub(gossipsub::Event::Message {
                message,
                ..
            })) => {
                if let Ok(gossip_message) = serde_json::from_slice(&message.data) {
                    if let Err(e) = self
                        .event_sender
                        .send(NetworkEvent::GossipMessage(gossip_message))
                        .await
                    {
                        log::error!("Failed to send gossip event to app: {}", e);
                    }
                }
            }
            swarm::SwarmEvent::Behaviour(AppBehaviourEvent::RequestResponse(
                request_response::Event::Message { peer, message },
            )) => match message {
                request_response::Message::Request {
                    request, channel, ..
                } => {
                    if let Err(e) = self
                        .event_sender
                        .send(NetworkEvent::InboundRequest {
                            peer_id: peer,
                            request,
                            channel,
                        })
                        .await
                    {
                        log::error!("Failed to send request event to app: {}", e);
                    }
                }
                request_response::Message::Response { response, .. } => {
                    if let Err(e) = self
                        .event_sender
                        .send(NetworkEvent::BlockResponse {
                            peer_id: peer,
                            response,
                        })
                        .await
                    {
                        log::error!("Failed to send response event to app: {}", e);
                    }
                }
            },
            swarm::SwarmEvent::NewListenAddr { address, .. } => {
                log::info!("Listening on {}", address);
            }
            _ => {}
        }
    }

    /// Handles commands received from the application logic.
    async fn handle_command(&mut self, command: NetworkCommand) {
        match command {
            NetworkCommand::Publish(message) => {
                let json = serde_json::to_string(&message).unwrap();
                if let Err(e) = self
                    .swarm
                    .behaviour_mut()
                    .gossipsub
                    .publish(self.topic.clone(), json.as_bytes())
                {
                    log::error!("Failed to publish gossip message: {:?}", e);
                }
            }
            NetworkCommand::RequestBlock { peer_id, request } => {
                self.swarm
                    .behaviour_mut()
                    .request_response
                    .send_request(&peer_id, request);
            }
            NetworkCommand::SendResponse { channel, response } => {
                self.swarm
                    .behaviour_mut()
                    .request_response
                    .send_response(channel, response)
                    .unwrap_or_else(|_| log::warn!("Failed to send response: channel closed."));
            }
        }
    }
}
